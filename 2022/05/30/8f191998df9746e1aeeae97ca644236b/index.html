<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>算法面试Python相关知识点 | Personnal Blog of YUAN Tingyi</title><meta name="author" content="YUAN Tingyi"><meta name="copyright" content="YUAN Tingyi"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="[toc] 算法面试 Python 相关知识点什么是解释性语言，什么是编译性语言？计算机不能直接理解高级语言，只能直接理解机器语言，所以必须要把高级语言翻译成机器语言，计算机才能执行高级语言编写的程序。  解释性语言在运行程序的时候才会进行翻译。  编译型语言写的程序在执行之前，需要一个专门的编译过程，把程序编译成机器语言（可执行文件）。   Python 程序运行过程？Python 程序在解释器">
<meta property="og:type" content="article">
<meta property="og:title" content="算法面试Python相关知识点">
<meta property="og:url" content="http://example.com/2022/05/30/8f191998df9746e1aeeae97ca644236b/index.html">
<meta property="og:site_name" content="Personnal Blog of YUAN Tingyi">
<meta property="og:description" content="[toc] 算法面试 Python 相关知识点什么是解释性语言，什么是编译性语言？计算机不能直接理解高级语言，只能直接理解机器语言，所以必须要把高级语言翻译成机器语言，计算机才能执行高级语言编写的程序。  解释性语言在运行程序的时候才会进行翻译。  编译型语言写的程序在执行之前，需要一个专门的编译过程，把程序编译成机器语言（可执行文件）。   Python 程序运行过程？Python 程序在解释器">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://example.com/img/4.jpg">
<meta property="article:published_time" content="2022-05-30T11:42:37.819Z">
<meta property="article:modified_time" content="2022-05-31T02:23:41.336Z">
<meta property="article:author" content="YUAN Tingyi">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/4.jpg"><link rel="shortcut icon" href="/img/favicon-32x32.png"><link rel="canonical" href="http://example.com/2022/05/30/8f191998df9746e1aeeae97ca644236b/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: 'Just',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '算法面试Python相关知识点',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-05-31 10:23:41'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.2.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar.jpeg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">28</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">0</div></a></div><hr/></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/4.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Personnal Blog of YUAN Tingyi</a></span><div id="menus"><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">算法面试Python相关知识点</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2022-05-30T11:42:37.819Z" title="Created 2022-05-30 19:42:37">2022-05-30</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2022-05-31T02:23:41.336Z" title="Updated 2022-05-31 10:23:41">2022-05-31</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="算法面试Python相关知识点"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post View:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>[toc]</p>
<h1 id="算法面试-Python-相关知识点"><a href="#算法面试-Python-相关知识点" class="headerlink" title="算法面试 Python 相关知识点"></a>算法面试 Python 相关知识点</h1><h2 id="什么是解释性语言，什么是编译性语言？"><a href="#什么是解释性语言，什么是编译性语言？" class="headerlink" title="什么是解释性语言，什么是编译性语言？"></a>什么是解释性语言，什么是编译性语言？</h2><p>计算机不能直接理解高级语言，只能直接理解机器语言，所以必须要把高级语言翻译成机器语言，计算机才能执行高级语言编写的程序。</p>
<ul>
<li><p>解释性语言在运行程序的时候才会进行翻译。</p>
</li>
<li><p>编译型语言写的程序在执行之前，需要一个专门的编译过程，把程序编译成机器语言（可执行文件）。</p>
</li>
</ul>
<h2 id="Python-程序运行过程？"><a href="#Python-程序运行过程？" class="headerlink" title="Python 程序运行过程？"></a>Python 程序运行过程？</h2><p>Python 程序在解释器上执行分两个过程：</p>
<ul>
<li><p>编译：<br>首先把程序的字节码保存为一个以.pyc 为扩展名的文件。作为一种启动速度的优化。下一次运行程序时，如果上没有修改过源码的话，Python 将会加载.pyc 文件并跳过编译这个步骤。</p>
</li>
<li><p>执行：<br>当程序编译成字节码后，发送到 Python 虚拟机上来执行。虚拟机是 Python 的运行引擎。是 Python 解释器的最后一步。</p>
</li>
</ul>
<p>注：解释器即让其他程序运行起来的程序，是代码与机器的计算机硬件之间的软件逻辑层。Python 也是一个名为解释器的软件包。</p>
<h2 id="Python-的作用域？"><a href="#Python-的作用域？" class="headerlink" title="Python 的作用域？"></a>Python 的作用域？</h2><p>Python 中的作用域分 4 种情况：</p>
<ul>
<li>L：local，局部作用域，即函数中定义的变量；</li>
<li>E：enclosing，嵌套的父级函数的局部作用域，即包含此函数的上级函数的局部作用域；</li>
<li>G：global，全局变量，就是模块级别定义的变量；</li>
<li>B：built-in，系统固定模块里面的变量，比如 int, bytearray 等。 搜索变量的优先级顺序依次是：作用域局部&gt;外层作用域&gt;当前模块中的全局&gt;python 内置作用域，也就是 LEGB。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="built_in">int</span>(<span class="number">2.9</span>)  <span class="comment"># int buiLt-in</span></span><br><span class="line">g_count = <span class="number">0</span> <span class="comment"># GLobaL</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">outer</span>():</span><br><span class="line">    o_count = <span class="number">1</span> <span class="comment"># EncLosing</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">inner</span>():</span><br><span class="line">        i_count = <span class="number">2</span> <span class="comment"># LocaL</span></span><br><span class="line">        <span class="built_in">print</span>(o_count)</span><br><span class="line">    <span class="comment"># print(i_count)  找不到</span></span><br><span class="line">    inner()</span><br><span class="line">outer()</span><br><span class="line"><span class="comment"># print(o_count)  # 找不到</span></span><br></pre></td></tr></table></figure>

<h2 id="Python-的数据结构？"><a href="#Python-的数据结构？" class="headerlink" title="Python 的数据结构？"></a>Python 的数据结构？</h2><p>Python 中的绝大部分数据结构可以被最终分解为三种类型：集合（Set），序列（Sequence），映射（Mapping）。</p>
<ul>
<li><ol>
<li>集合是独立于标量，序列和映射之外的特殊数据结构，它支持数学理论的各种集合的运算。它的存在使得用程序代码实现数学理论变得方便。</li>
</ol>
</li>
<li><ol start="2">
<li>序列是 Python 中最为基础的内建类型。它分为七种类型：列表、字符串、元组、Unicode 字符串、字节数组、缓冲区和 xrange 对象。常用的是：列表（List）、字符串（String）、元组（Tuple）。</li>
</ol>
</li>
<li><ol start="3">
<li>映射在 Python 的实现是数据结构字典（Dictionary）。作为第三种基本单位，映射的灵活使得它在多种场合中都有广泛的应用和良好的可拓展性。</li>
</ol>
</li>
</ul>
<p>Python 可变类型是列表、集合、字典，不可变有字符串、元组、数字。</p>
<h2 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h2><ul>
<li>进程：一个运行的程序（代码）就是一个进程，没有运行的代码叫程序，进程是<strong>系统资源分配的最小单位</strong>，进程拥有自己独立的内存空间，所有进程间数据不共享，开销大。</li>
<li>线程：<strong>CPU 调度执行的最小单位</strong>，也叫执行路径，不能独立存在，依赖进程存在，一个进程至少有一个线程，叫主线程，而多个线程共享内存（数据共享，共享全局变量),从而极大地提高了程序的运行效率。</li>
<li>多线程<ul>
<li>Python 在任意时刻，只有一个线程在解释器中运行。对 Python 虚拟机的访问由全局解释器锁（GIL）来控制，正是这个锁能保证同一时刻只有一个线程在运行。</li>
<li>多线程共享主进程的资源，所以可能还会改变其中的变量，这个需加上线程锁，每次执行完一个线程再执行下一个线程。</li>
<li>一个 CPU 在同一个时刻只能执行一个线程，但是当遇到 IO 操作或者运行一定的代码量的时候就会释放全局解释器锁，执行另外一个线程。</li>
</ul>
</li>
<li>互斥锁和死锁<ul>
<li>互斥锁：即确保某段关键代码的数据只能又一个线程从头到尾完整执行，保证了这段代码数据的安全性，但是这样就会导致死锁。</li>
<li>死锁：多个子线程在等待对方解除占用状态，但是都不先解锁，互相等待，这就是死锁。</li>
</ul>
</li>
</ul>
<h2 id="Lambda"><a href="#Lambda" class="headerlink" title="Lambda"></a>Lambda</h2><p>lambda 函数是一个可以接收任意多个参数(包括可选参数)并且返回单个表达式值的函数。</p>
<ul>
<li>1.lambda 函数比较轻便，即用即仍，很适合需要完成一项功能，但是此功能只在此一处使用，连名字都很随意的情况下。</li>
<li>2.匿名函数，一般用来给 filter，map 这样的函数式编程服务。</li>
<li>3.作为回调函数，传递给某些应用，比如消息处理。</li>
</ul>
<h2 id="浅拷贝和深拷贝"><a href="#浅拷贝和深拷贝" class="headerlink" title="浅拷贝和深拷贝"></a>浅拷贝和深拷贝</h2><ul>
<li>浅拷贝(copy)：创建新对象，其内容是原对象的引用。拷贝父对象，不会拷贝对象的内部的子对象。</li>
<li>深拷贝(deepcopy)： copy 模块的 deepcopy 方法，完全拷贝了父对象及其子对象。深拷贝出来的对象是一个全新的对象，不再与原来的对象有任何关联。</li>
</ul>
<p>解析：</p>
<ul>
<li>变量：是一个系统表的元素，拥有指向对象的连接空间</li>
<li>对象：被分配的一块内存，存储其所代表的值</li>
<li>引用：是自动形成的从变量到对象的指针</li>
<li>类型：属于对象，而非变量</li>
<li>不可变对象：一旦创建就不可修改的对象，包括字符串、元组、数值类型，不可变类型，不管是深拷贝还是浅拷贝，地址值和拷贝后的值都是一样的。（该对象所指向的内存中的值不能被改变。当改变某个变量时候，由于其所指的值不能被改变，相当于把原来的值复制一份后再改变，这会开辟一个新的地址，变量再指向这个新的地址。）</li>
<li>可变对象：可以修改的对象，包括列表、字典、集合（该对象所指向的内存中的值可以被改变。变量（准确的说是引用）改变后，实际上是其所指的值直接发生改变，并没有发生复制行为，也没有开辟新的地址，通俗点说就是原地改变。）</li>
</ul>
<p>当写 a &#x3D; ‘python’，Python 解释器干的事情：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.创建变量a</span><br><span class="line">2.创建一个对象(分配一块内存)，来存储值 ‘python’</span><br><span class="line">3.将变量与对象，通过指针连接起来，从变量到对象的连接称之为引用(变量引用对象)</span><br></pre></td></tr></table></figure>

<ul>
<li><ol>
<li><strong>赋值</strong>：只是复制了新对象的引用，不会开辟新的内存空间。并不会产生一个独立的对象单独存在，只是将原有的数据块打上一个新标签，所以当其中一个标签被改变的时候，数据块就会发生变化，另一个标签也会随之改变。</li>
</ol>
</li>
<li><ol start="2">
<li><strong>浅拷贝</strong>：创建新对象，其内容是原对象的引用。</li>
</ol>
<p>浅拷贝有三种形式： 切片操作，工厂函数，copy 模块中的 copy 函数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">如： lst = [1,2,[3,4]]</span><br><span class="line">    切片操作：lst1 = lst[:] 或者 lst1 = [each for each in lst]</span><br><span class="line">    工厂函数：lst1 = list(lst)</span><br><span class="line">    copy函数：lst1 = copy.copy(lst)</span><br></pre></td></tr></table></figure>

<p>浅拷贝之所以称为浅拷贝，是它仅仅只拷贝了一层，拷贝了最外围的对象本身，内部的元素都只是拷贝了一个引用而已，在 lst 中有一个嵌套的 list[3,4]，如果修改了它，情况就不一样了。</p>
<ul>
<li><p>浅拷贝要分两种情况进行讨论：</p>
</li>
<li><ol>
<li>当浅拷贝的值是不可变对象（字符串、元组、数值类型）时和“赋值”的情况一样，对象的 id 值（id()函数用于获取对象的内存地址）与浅拷贝原来的值相同。<br> - 2. 当浅拷贝的值是可变对象（列表、字典、集合）时会产生一个“不是那么独立的对象”存在。有两种情况：<strong>第一种情况</strong>：复制的对象中无复杂子对象[1,2,3,4,5,6]，原来值的改变并不会影响浅复制的值，同时浅复制的值改变也并不会影响原来的值。原来值的 id 值与浅复制原来的值不同。<strong>第二种情况</strong>：复制的对象中有复杂子对象（例如列表中的一个子元素是一个列表[1,2,3,[4,5],6]），如果不改变其中复杂子对象，浅复制的值改变并不会影响原来的值。 但是改变原来的值中的复杂子对象的值会影响浅复制的值。</li>
</ol>
</li>
</ul>
</li>
<li><ol start="3">
<li><strong>深拷贝</strong>：和浅拷贝对应，深拷贝拷贝了对象的所有元素，包括多层嵌套的元素。深拷贝出来的对象是一个全新的对象，不再与原来的对象有任何关联。所以改变原有被复制对象不会对已经复制出来的新对象产生影响。</li>
</ol>
</li>
</ul>
<h2 id="Python-多线程是否能用多个-CPU，为什么？"><a href="#Python-多线程是否能用多个-CPU，为什么？" class="headerlink" title="Python 多线程是否能用多个 CPU，为什么？"></a>Python 多线程是否能用多个 CPU，为什么？</h2><p>Python 的多线程不能利用多核 CPU。<br>因为 Python 解释器使用了 GIL（Global Interpreter Lock），在任意时刻中只允许单个 Python 线程运行。无论系统有多少个 CPU 核心，Python 程序都只能在一个 CPU 上运行 。<br>注：GIL 的功能是：在 CPython 解释器中执行的每一个 Python 线程，都会先锁住自己，以阻止别的线程执行。</p>
<h2 id="Python-垃圾回收机制"><a href="#Python-垃圾回收机制" class="headerlink" title="Python 垃圾回收机制"></a>Python 垃圾回收机制</h2><p>Python 的垃圾回收机制是以：引用计数器为主，标记清除和分代回收为辅。</p>
<ul>
<li><ol>
<li>引用计数：每个对象内部都维护了一个值，该值记录这此对象被引用的次数，如果次数为 0，则 Python 垃圾回收机制会自动清除此对象。</li>
</ol>
</li>
<li><ol start="2">
<li>标记-清除（Mark—Sweep）：被分配对象的计数值与被释放对象的计数值之间的差异累计超过某个阈值，则 Python 的收集机制就启动</li>
</ol>
<ul>
<li>标记阶段，遍历所有的对象，如果是可达的（reachable），也就是还有对象引用它，那么就标记该对象为可达。</li>
<li>清除阶段，再次遍历对象，如果发现某个对象没有标记为可达，则就将其回收。</li>
</ul>
</li>
<li><ol start="3">
<li>“分代回收”(Generational Collection)。当代码中主动执行 gc.collect() 命令时，Python 解释器就会进行垃圾回收。</li>
</ol>
</li>
</ul>
<p>总体来说，在 Python 中，主要通过引用计数进行垃圾回收；通过 “标记-清除” 解决容器对象可能产生的循环引用问题；通过 “分代回收” 以空间换时间的方法提高垃圾回收效率。</p>
<h2 id="Python-生成器"><a href="#Python-生成器" class="headerlink" title="Python 生成器"></a>Python 生成器</h2><p>生成器是一种可以简单有效的创建迭代器的工具。像常规函数一样撰写，但是在需要返回数据时使用 yield 语句。每当对它调用 next()函数，生成器从它上次停止的地方重新开始（它会记住所有的数据值和上次执行的语句）。</p>
<h2 id="Python-迭代器和生成器的区别"><a href="#Python-迭代器和生成器的区别" class="headerlink" title="Python 迭代器和生成器的区别"></a>Python 迭代器和生成器的区别</h2><ul>
<li>迭代器有两个方法 next 方法和 iter 方法，iter 方法获取对象的迭代器，next 方法返回下一个迭代器。</li>
<li>生成器：使用了 yield 的函数被称为生成器（generator），在调用生成器运行的过程中，每次遇到 yield 时函数会暂停并保存当前所有的运行信息，返回 yield 的值, 并在下一次执行 next() 方法时从当前位置继续运行。调用一个生成器函数，返回的是一个迭代器对象。</li>
</ul>
<p>区别：</p>
<ul>
<li>1.语法上：生成器是通过函数的形式中调用 yield 或（）的形式创建的；迭代器可以通过 iter（） 内置函数创建</li>
<li>2.用法上：生成器在调用 next（）函数或 for 循环中，所有过程被执行，且返回值；迭代器在调用 next（）函数或 for 循环中，所有值被返回，没有其他过程或说动作。</li>
</ul>
<p>总结：</p>
<ul>
<li>迭代器：在循环遍历自定义容器对象时，会使用 python 内置函数 iter()调用遍历对象的_iter_(self)获得一个迭代器，之后再循环对这个迭代器使用 next()调用迭代器对象的_next_(self) 。</li>
<li>生成器：只能遍历一次，是一类特殊的迭代器。生成器能做到迭代器能做的所有事，而且因为自动创建了 iter()和 next()方法，生成器显得特别简洁，而且生成器也是高效的，使用生成器表达式取代列表解析可以同时节省内存。除了创建和保存程序状态的自动方法，当发生器终结时，还会自动抛出 StopIteration 异常。</li>
</ul>
<h2 id="什么是闭包"><a href="#什么是闭包" class="headerlink" title="什么是闭包"></a>什么是闭包</h2><p>在一个内部函数中，对外部作用域的变量进行引用，(并且一般外部函数的返回值为内部函数)，那么内部函数就被认为是闭包。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">outer</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">inner</span>(<span class="params">y</span>):</span><br><span class="line">        <span class="keyword">return</span> x + y</span><br><span class="line">    <span class="keyword">return</span> inner</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(outer(<span class="number">6</span>)(<span class="number">5</span>))</span><br><span class="line">-----------------------------</span><br><span class="line">&gt;&gt;&gt;<span class="number">11</span></span><br></pre></td></tr></table></figure>

<p>如代码所示，在 outer 函数内，又定义了一个 inner 函数，并且 inner 函数又引用了外部函数 outer 的变量 x，这就是一个闭包了。在输出时，outer(6)(5)，第一个括号传进去的值返回 inner 函数，其实就是返回 6 + y，所以再传第二个参数进去，就可以得到返回值，6 + 5。</p>
<h2 id="Python-装饰器"><a href="#Python-装饰器" class="headerlink" title="Python 装饰器"></a>Python 装饰器</h2><p>装饰器本质上是一个 Python 函数，它可以让其他函数在不需要做任何代码变动的前提下增加额外功能。<br>装饰器的返回值也是一个函数对象，它经常用于有切面需求的场景，比如：插入日志 性能测试 事务处理 缓存 权限校验等场景 装饰器是解决这类问题的绝佳设计。<br>有了装饰器，就可以抽离出大量与函数功能本身无关的雷同代码并继续重用，概括的讲，装饰器的作用就是为已经存在的对象添加额外的功能。</p>
<h3 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h3><p>函数 use_logging 就是装饰器，它把执行真正业务方法的 func 包裹在函数里面，看起来像 bar 被 use_logging 装饰了。@符号是装饰器的语法糖，在定义函数的时候使用，避免再一次赋值操作。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">use_logging</span>(<span class="params">func</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">wrapper</span>(<span class="params">*args, **kwargs</span>):</span><br><span class="line">    	logging.warn(<span class="string">&quot;%s is running&quot;</span> % func.__name__)</span><br><span class="line">    	<span class="keyword">return</span> func(*args, **kwargs)</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="meta">@use_logging</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">bar</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;i am bar&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@use_logging</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">foo</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;i am foo&#x27;</span>)</span><br><span class="line"></span><br><span class="line">bar()</span><br><span class="line">------------------------</span><br><span class="line">&gt;&gt;&gt;bar <span class="keyword">is</span> running</span><br><span class="line">&gt;&gt;&gt;i am bar</span><br></pre></td></tr></table></figure>

<h3 id="带参数的装饰器"><a href="#带参数的装饰器" class="headerlink" title="带参数的装饰器"></a>带参数的装饰器</h3><p>装饰器的语法允许我们在调用时，提供其它参数，比如@decorator(a)。这样，就为装饰器的编写和使用提供了更大的灵活性。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">use_logging</span>(<span class="params">level</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">decorator</span>(<span class="params">func</span>):</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">wrapper</span>(<span class="params">*args, **kwargs</span>):</span><br><span class="line">        	<span class="keyword">if</span> level == <span class="string">&quot;warn&quot;</span>:</span><br><span class="line">        		logging.warn(<span class="string">&quot;%s is running&quot;</span> % func.__name__)</span><br><span class="line">        	<span class="keyword">return</span> func(*args)</span><br><span class="line">        <span class="keyword">return</span> wrapper</span><br><span class="line">    <span class="keyword">return</span> decorator</span><br><span class="line"></span><br><span class="line"><span class="meta">@use_logging(<span class="params">level=<span class="string">&quot;warn&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">foo</span>(<span class="params">name=<span class="string">&#x27;foo&#x27;</span></span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;i am %s&quot;</span> % name)</span><br><span class="line"></span><br><span class="line">foo()</span><br><span class="line">------------------------</span><br><span class="line">&gt;&gt;&gt;foo <span class="keyword">is</span> running</span><br><span class="line">&gt;&gt;&gt;i am foo</span><br></pre></td></tr></table></figure>

<h3 id="类装饰器"><a href="#类装饰器" class="headerlink" title="类装饰器"></a>类装饰器</h3><p>相比函数装饰器，类装饰器具有灵活度大、高内聚、封装性等优点。使用类装饰器还可以依靠类内部的__call__方法，当使用 @ 形式将装饰器附加到函数上时，就会调用此方法。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, func</span>):</span><br><span class="line">        self._func = func</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__call__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span> (<span class="string">&#x27;class decorator runing&#x27;</span>)</span><br><span class="line">        self._func()</span><br><span class="line">        <span class="built_in">print</span> (<span class="string">&#x27;class decorator ending&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@Foo</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">bar</span>():</span><br><span class="line">    <span class="built_in">print</span> (<span class="string">&#x27;bar&#x27;</span>)</span><br><span class="line"></span><br><span class="line">bar()</span><br><span class="line">------------------------</span><br><span class="line">&gt;&gt;&gt;<span class="keyword">class</span> <span class="title class_">decorator</span> runing</span><br><span class="line">&gt;&gt;&gt;bar</span><br><span class="line">&gt;&gt;&gt;<span class="keyword">class</span> <span class="title class_">decorator</span> ending</span><br></pre></td></tr></table></figure>

<h2 id="Python-中-yield-和-return-的区别"><a href="#Python-中-yield-和-return-的区别" class="headerlink" title="Python 中 yield 和 return 的区别"></a>Python 中 yield 和 return 的区别</h2><ul>
<li>共同点：<code>return</code>和<code>yield</code>都用来返回值；在一次性地返回所有值场景中<code>return</code>和<code>yield</code>的作用是一样的。</li>
<li>不同点：如果要返回的数据是通过<code>for</code>等循环生成的迭代器类型数据（如列表、元组），<code>return</code>只能在循环外部一次性地返回，<code>yeild</code>则可以在循环内部逐个元素返回（<code>yield</code> 函数会暂停并保存当前所有的运行信息，返回 <code>yield</code> 的值, 并在下一次执行 <code>next()</code> 方法时从当前位置继续运行）</li>
</ul>
<h2 id="Python-中-set-的底层实现"><a href="#Python-中-set-的底层实现" class="headerlink" title="Python 中 set 的底层实现"></a>Python 中 set 的底层实现</h2><p>散列表&#x2F;哈希表。set 只是默认键和值是相同的。<br>注：散列表是根据关键字而直接进行访问值的数据结构。也就是说散列表建立了关键字和存储地址之间的一种直接映射关系。</p>
<h2 id="Python-中字典与-set-区别？"><a href="#Python-中字典与-set-区别？" class="headerlink" title="Python 中字典与 set 区别？"></a>Python 中字典与 set 区别？</h2><ul>
<li>1.字典是一系列无序的键值对的组合；集合 set()里的元素默认键值是一样的，是单一的一个元素。</li>
<li>2.从 python3.6 后，字典有序；集合无序。</li>
<li>3.字典键不能重复；集合 set()元素不能重复。</li>
</ul>
<h2 id="Python-中-init-和-new-和-call-的区别？"><a href="#Python-中-init-和-new-和-call-的区别？" class="headerlink" title="Python 中__init__和__new__和__call__的区别？"></a>Python 中__init__和__new__和__call__的区别？</h2><ul>
<li><code>__init__</code>是初始化方法</li>
<li><code>__new__</code>实例化对象</li>
<li><code>__call__</code>允许一个类的实例像函数一样被调用。实质上说，这意味着 x() 与 x.call() 是相同。</li>
</ul>
<p>构造方法 &#x3D; 创建对象 + 初始化对象 &#x3D; <code>new</code> + <code>init</code><br><code>__new__</code>方法是在实例创建之前被调用，是一个静态方法，主要的功能就是创建一个类的实例并返回<br><code>__init__</code>方法是在实例创建之后被调用，主要的功能是设置实例的一些属性初始值</p>
<p>实际测试：<code>__new__</code>在<code>__init__</code>之前被调用，<code>__new__</code>的返回值（实例）将传递给<code>__init__</code>方法的第一个参数（self），然后<code>__init__</code>给这个实例(self)设置一些参数。</p>
<h2 id="Python-中的内存管理"><a href="#Python-中的内存管理" class="headerlink" title="Python 中的内存管理"></a>Python 中的内存管理</h2><h3 id="什么是内存管理器（what）"><a href="#什么是内存管理器（what）" class="headerlink" title="什么是内存管理器（what）"></a>什么是内存管理器（what）</h3><p>Python 作为一个高层次的结合了解释性、编译性、互动性和面向对象的脚本语言，与大多数编程语言不同，Python 中的变量无需事先申明，变量无需指定类型，程序员无需关心内存管理，Python 解释器给你自动回收。开发人员不用过多的关心内存管理机制，这一切全部由 Python 内存管理器承担了复杂的内存管理工作。</p>
<p>内存不外乎创建和销毁两部分，本文将围绕 python 的内存池和垃圾回收两部分进行分析。</p>
<h3 id="Python-内存池"><a href="#Python-内存池" class="headerlink" title="Python 内存池"></a>Python 内存池</h3><p><strong>为什么要引入内存池（why）</strong></p>
<p>当创建大量消耗小内存的对象时，频繁调用 new&#x2F;malloc 会导致大量的内存碎片，致使效率降低。内存池的作用就是预先在内存中申请一定数量的，大小相等的内存块留作备用，当有新的内存需求时，就先从内存池中分配内存给这个需求，不够之后再申请新的内存。这样做最显著的优势就是能够减少内存碎片，提升效率。</p>
<p>Python 中的内存管理机制为<strong>Pymalloc</strong>。</p>
<p><strong>内存池是如何工作的（how）</strong><br>首先，我们看一张 CPython(python 解释器)的内存架构图：</p>
<p><img src="/resource/e6695e0f6d82420ba3686e5bed395bc8.png" alt="2022-05-16-21-36-24.png"></p>
<ul>
<li>Python 的对象管理主要位于 Level+1~Level+3 层。</li>
<li>Level+3 层：对于 Python 内置的对象（比如 int,dict 等）都有独立的私有内存池，对象之间的内存池不共享，即 int 释放的内存，不会被分配给 float 使用。</li>
<li>Level+2 层：当申请的内存大小 &lt; 256KB 时，内存分配主要由 Python 对象分配器（Python’s object allocator）实施。</li>
<li>Level+1 层：当申请的内存大小 &gt; 256KB 时，由 Python 原生的内存分配器进行分配，本质上是调用 C 标准库中的 malloc&#x2F;realloc 等函数</li>
</ul>
<p><strong>内存释放</strong></p>
<p>关于释放内存方面，当一个对象的<strong>引用计数</strong>变为 0 时，Python 就会调用它的<strong>析构函数</strong>。调用析构函数并不意味着最终一定会调用 free 来释放内存空间，如果真是这样的话，那频繁地申请、释放内存空间会使 Python 的执行效率大打折扣。因此在析构时也采用了内存池机制，从内存池申请到的内存会被归还到内存池中，以避免频繁地申请和释放动作。</p>
<h3 id="垃圾回收机制"><a href="#垃圾回收机制" class="headerlink" title="垃圾回收机制"></a>垃圾回收机制</h3><p>Python 的垃圾回收机制采用<strong>引用计数</strong>机制为主，<strong>标记-清除</strong>和<strong>分代回收</strong>机制为辅的策略。其中，<strong>标记-清除</strong>机制用来解决计数引用带来的循环引用而无法释放内存的问题，<strong>分代回收</strong>机制是为提升垃圾回收的效率。</p>
<h4 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h4><p>Python 通过引用计数来保存内存中的变量追踪，即记录该对象被其他使用的对象引用的次数。</p>
<p>Python 中有个内部跟踪变量叫做引用计数器，每个变量有多少个引用，简称引用计数。当某个对象的引用计数为 0 时，就列入了垃圾回收队列。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> sys</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sys.getrefcount(a)  <span class="comment"># 获取对象a的引用次数</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = a</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sys.getrefcount(a)</span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">del</span> b  <span class="comment"># 删除b的引用</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sys.getrefcount(a)</span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c = <span class="built_in">list</span>()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c.append(a) <span class="comment"># 加入到容器中</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sys.getrefcount(a)</span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">del</span> c  <span class="comment"># 删除容器，引用-1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sys.getrefcount(a)</span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = a</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sys.getrefcount(a)</span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = [<span class="number">3</span>, <span class="number">4</span>]  <span class="comment"># 重新赋值</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sys.getrefcount(a)</span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">注意：当把a作为参数传递给getrefcount时，会产生一个临时的引用，因此得出来的结果比真实情况 + 1</span><br></pre></td></tr></table></figure>

<p><strong>引用计数增加的情况</strong>：</p>
<ul>
<li>一个对象被分配给一个新的名字（例如：<code>a = [1, 2]</code>）</li>
<li>将其放入一个容器中（如列表、元组或字典）（例如：<code>c.append(a)</code>）</li>
</ul>
<p><strong>引用计数减少的情况</strong>：</p>
<ul>
<li>使用<code>del</code>语句对对象别名显式的销毁(例如：<code>del b</code>)</li>
<li>对象所在的容器被销毁或从容器中删除对象（例如：<code>del c</code> ）</li>
<li>引用超出作用域或被重新赋值（例如：<code>a = [3,4]</code>）</li>
</ul>
<p>引用计数能够解决大多数垃圾回收的问题，但是遇到<strong>两个对象相互引用</strong>的情况，del 语句可以减少引用次数，但是引用计数不会归 0，对象也就不会被销毁，从而造成了内存泄漏问题。针对该情况，Python 引入了<strong>标记-清除</strong>机制。</p>
<h4 id="标记-清除（Mark-and-Sweep）"><a href="#标记-清除（Mark-and-Sweep）" class="headerlink" title="标记-清除（Mark-and-Sweep）"></a>标记-清除（Mark-and-Sweep）</h4><p><strong>标记-清除</strong>用来解决引用计数机制产生的<strong>循环引用</strong>，进而导致内存泄漏的问题。循环引用只有在容器对象才会产生，比如字典，元组，列表等。</p>
<p>顾名思义，该机制在进行垃圾回收时分成了两步，分别是：</p>
<ul>
<li><strong>标记阶段</strong>，遍历所有的对象，如果是可达的（reachable），也就是还有对象引用它，那么就标记该对象为可达。</li>
<li><strong>清除阶段</strong>，再次遍历对象，如果发现某个对象没有标记为可达（即为 Unreachable），则就将其回收。</li>
</ul>
<p>当一个对象被创建时，它的标记位被设置为 <code>0（False）</code>。<br>在标记阶段，从根结点出发，也就是可以直接访问的局部变量，采用图的遍历算法，比如 <code>DFS</code>，将所有可达对象的标记位设置为 <code>1（True）</code>。<br>在清除阶段，线性扫描堆内存，将不可达对象直接释放，将可达对象的标记位重新设置为 <code>0</code>，为下一次标记清除做准备。<br>标记清除的优点是可以处理循环引用，缺点是算法会暂停程序的执行。为了优化垃圾回收的性能，可以使用分代回收算法。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = [<span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sys.getrefcount(a)</span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sys.getrefcount(b)</span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.append(b)</span><br><span class="line">* * *</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sys.getrefcount(b)</span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b.append(a)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sys.getrefcount(a)</span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">del</span> a</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">del</span> b</span><br></pre></td></tr></table></figure>

<ul>
<li><code>a</code>引用<code>b</code>，<code>b</code>引用<code>a</code>, 此时两个对象各自被引用了 2 次（去除 getrefcout()的临时引用）</li>
<li>执行<code>del</code>之后，对象<code>a</code>, <code>b</code>的引用次数都减 1，此时各自的引用计数器都为 1，陷入循环引用。</li>
<li>标记：找到其中的一端<code>a</code>，因为它有一个对<code>b</code>的引用，则将<code>b</code>的引用计数减 1。</li>
<li>标记：再沿着引用到<code>b</code>，<code>b</code>有一个<code>a</code>的引用，将<code>a</code>的引用计数减 1，此时对象<code>a</code>和<code>b</code>的引用次数全部为 0，被标记为不可达（Unreachable）。</li>
<li>清除: 被标记为不可达的对象就是真正需要被释放的对象</li>
</ul>
<p>上面描述的垃圾回收的阶段，会暂停整个应用程序，等待标记清除结束后才会恢复应用程序的运行。为了减少应用程序暂停的时间，Python 通过**“分代回收”(Generational Collection)**以空间换时间的方法提高垃圾回收效率。</p>
<h4 id="分代回收"><a href="#分代回收" class="headerlink" title="分代回收"></a>分代回收</h4><p><strong>分代回收</strong>是基于这样的一个统计事实，对于程序，存在一定比例的内存块的生存周期比较短；而剩下的内存块，生存周期会比较长，甚至会从程序开始一直持续到程序结束。生存期较短对象的比例通常在 80%～ 90%之间。 因此，简单地认为：对象存在时间越长，越可能不是垃圾，应该越少去收集。这样在执行标记-清除算法时可以有效减小遍历的对象数，从而提高垃圾回收的速度，是一种<strong>以空间换时间的方法策略</strong>。</p>
<p>Python 将所有的对象分为年轻代（第 0 代）、中年代（第 1 代）、老年代（第 2 代）三代。所有的新建对象默认是 第 0 代对象。当在第 0 代的 gc 扫描中存活下来的对象将被移至第 1 代，在第 1 代的 gc 扫描中存活下来的对象将被移至第 2 代。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gc扫描次数（第0代&gt;第1代&gt;第2代）</span><br></pre></td></tr></table></figure>

<p>当某一代中被分配的对象与被释放的对象之差达到某一阈值时，就会触发当前一代的<strong>gc 扫描</strong>。当某一代被扫描时，比它年轻的一代也会被扫描，因此，第 2 代的 gc 扫描发生时，第 0，1 代的 gc 扫描也会发生，即为<strong>全代扫描</strong>。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> gc</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>gc.get_threshold()  <span class="comment"># 分代回收机制的参数阈值设置</span></span><br><span class="line">(<span class="number">700</span>, <span class="number">10</span>, <span class="number">10</span>)</span><br><span class="line"><span class="comment"># 700=新分配的对象数量-释放的对象数量，第0代gc扫描被触发</span></span><br><span class="line"><span class="comment"># 第一个10：第0代gc扫描发生10次，则第1代的gc扫描被触发</span></span><br><span class="line"><span class="comment"># 第二个10：第1代的gc扫描发生10次，则第2代的gc扫描被触发</span></span><br></pre></td></tr></table></figure>

<p>总体而言，Python 通过<strong>内存池</strong>来减少内存碎片化，提高执行效率。主要通过<strong>引用计数</strong>来完成垃圾回收，通过<strong>标记-清除</strong>解决容器对象循环引用造成的问题，通过<strong>分代回收</strong>提高垃圾回收的效率。</p>
<h2 id="类方法和静态方法的区别"><a href="#类方法和静态方法的区别" class="headerlink" title="类方法和静态方法的区别"></a>类方法和静态方法的区别</h2><p>Python 类方法和实例方法相似，它最少也要包含一个参数，只不过类方法中通常将其命名为 cls，Python 会自动将类本身绑定给 cls 参数（注意，绑定的不是类对象）。也就是说，在调用类方法时，无需显式为 cls 参数传参。</p>
<p>静态方法没有类似 self、cls 这样的特殊参数，因此 Python 解释器不会对它包含的参数做任何类或对象的绑定。也正因为如此，类的静态方法中无法调用任何类属性和类方法。</p>
<p>实例方法只能被实例对象调用(Python3 中，如果类调用实例方法，需要显示的传 self, 也就是实例对象自己)，静态方法(由@staticmethod 装饰的方法)、类方法(由@classmethod 装饰的方法)，可以被类或类的实例对象调用。</p>
<ul>
<li>实例方法，第一个参数必须要默认传实例对象，一般习惯用 self。</li>
<li>静态方法，参数没有要求。</li>
<li>类方法，第一个参数必须要默认传类，一般习惯用 cls。</li>
</ul>
<h2 id="Python-的错误和异常处理"><a href="#Python-的错误和异常处理" class="headerlink" title="Python 的错误和异常处理"></a>Python 的错误和异常处理</h2><p>Python 中会发生两种类型的错误。</p>
<ul>
<li><ol>
<li>语法错误：如果未遵循正确的语言语法，则会引发语法错误。</li>
</ol>
</li>
<li><ol start="2">
<li>逻辑错误（异常）：在运行时中，通过语法测试后发生错误的情况称为异常或逻辑类型。</li>
</ol>
</li>
</ul>
<p><strong>异常处理</strong><br>通过使用 <code>try</code>…<code>except</code> 来处理异常状况。一般来说会把通常的语句放在 <code>try</code> 代码块中，将错误处理器代码放置在 <code>except</code> 代码块中。</p>
<ul>
<li>try…else 语句：else 语句是在 try 语句中的代码没有任何异常的情况下，再执行 else 语句下的代码。</li>
<li>try…finally 语句：finally 语句就是不管上面有没有异常，都要执行 finally 语句下的代码，通常是做一些必须要释放的资源的代码，最典型的就是文件操作和数据库操作。</li>
<li>抛出异常 raise：raise 语句是抛出一个指定的异常。</li>
</ul>
<h2 id="Python-中的-is-和-x3D-x3D-的区别"><a href="#Python-中的-is-和-x3D-x3D-的区别" class="headerlink" title="Python 中的 is 和&#x3D;&#x3D;的区别"></a>Python 中的 is 和&#x3D;&#x3D;的区别</h2><ul>
<li><code>is</code>比较的是两个对象的 id 值是否相等，也就是比较两个对象是否为同一个实例对象，是否指向同一个内存地址。</li>
<li><code>==</code>比较的是两个对象的内容是否相等，默认会调用对象的<code>eq()</code>方法。</li>
</ul>
<h2 id="GBK-和-UTF-8-的区别"><a href="#GBK-和-UTF-8-的区别" class="headerlink" title="GBK 和 UTF-8 的区别"></a>GBK 和 UTF-8 的区别</h2><ul>
<li>GBK 是在国家标准 GB2312 基础上扩容后兼容 GB2312 的标准。GBK 编码专门用来解决中文编码的，是双字节的。不论中英文都是双字节的。</li>
<li>UTF－8 编码是用以解决国际上字符的一种多字节编码，它对英文使用 8 位（即一个字节），中文使用 24 位（三个字节）来编码。对于英文字符较多的论坛则用 UTF－8 节省空间。另外，如果是外国人访问 GBK 网页，需要下载中文语言包支持。访问 UTF-8 编码的网页则不出现这问题。可以直接访问。</li>
<li>GBK 包含全部中文字符；UTF-8 则包含全世界所有国家需要用到的字符。</li>
</ul>
<h2 id="Python-遍历字典的方法"><a href="#Python-遍历字典的方法" class="headerlink" title="Python 遍历字典的方法"></a>Python 遍历字典的方法</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">dic1 = &#123;<span class="string">&#x27;date&#x27;</span>:<span class="string">&#x27;2018.11.2&#x27;</span>,<span class="string">&#x27;name&#x27;</span>:<span class="string">&#x27;carlber&#x27;</span>,<span class="string">&#x27;work&#x27;</span>:<span class="string">&quot;遍历&quot;</span>,<span class="string">&#x27;number&#x27;</span>:<span class="number">3</span>&#125;</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> dic1:</span><br><span class="line">    <span class="built_in">print</span>(i)</span><br><span class="line"><span class="keyword">for</span> key <span class="keyword">in</span> dic1.keys():   <span class="comment">#遍历字典中的键</span></span><br><span class="line">    <span class="built_in">print</span>(key)</span><br><span class="line"><span class="keyword">for</span> value <span class="keyword">in</span> dic1.values():  <span class="comment">#遍历字典中的值</span></span><br><span class="line">    <span class="built_in">print</span>(value)</span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> dic1.items():  <span class="comment">#遍历字典中的元素</span></span><br><span class="line">    <span class="built_in">print</span>(item)</span><br></pre></td></tr></table></figure>

<h2 id="init-py文件的作用以及意义"><a href="#init-py文件的作用以及意义" class="headerlink" title="__init__.py文件的作用以及意义"></a><code>__init__.py</code>文件的作用以及意义</h2><ul>
<li>这个文件定义了包的属性和方法，它可以什么也不定义；可以只是一个空文件，但是必须存在。</li>
<li>如果 <code>__init__.py</code> 不存在，这个目录就仅仅是一个目录，而不是一个包，它就不能被导入或者包含其它的模块和嵌套包。</li>
<li>或者可以这样理解。这样，当导入这个包的时候，<code>__init__.py</code>文件自动运行。帮导入了这么多个模块，就不需要将所有的<code>import</code>语句写在一个文件里了，也可以减少代码量。</li>
</ul>
<h2 id="函数调用参数的传递方式是值传递还是引用传递？"><a href="#函数调用参数的传递方式是值传递还是引用传递？" class="headerlink" title="函数调用参数的传递方式是值传递还是引用传递？"></a>函数调用参数的传递方式是值传递还是引用传递？</h2><p>Python 的参数传递有：<strong>位置参数</strong>, <strong>默认参数</strong>, <strong>可变参数</strong>, <strong>关键字参数</strong>.</p>
<p>函数的传值到底是<strong>值传递</strong>还是<strong>引用传递</strong>, 要分情况：</p>
<ul>
<li><strong>不可变参数用值传递</strong>：像整数和字符串这样的不可变对象，是通过拷贝进行传递的，因为你无论如何都不可能在原处改变不可变对象.</li>
<li><strong>可变参数是引用传递</strong>：比如像列表, 字典这样的对象是通过引用传递, 和 C 语言里面的用指针传递数组很相似, 可变对象能在函数内部改变.</li>
</ul>
<h2 id="Python-的缺省参数"><a href="#Python-的缺省参数" class="headerlink" title="Python 的缺省参数"></a>Python 的缺省参数</h2><p>缺省参数指在调用函数的时候没有传入参数的情况下, 调用默认的参数, 在调用函数的同时赋值时, 所传入的参数会替代默认参数.</p>
<ul>
<li><code>*args</code>是不定长参数，它可以表示输入参数是不确定的，可以是任意多个。</li>
<li><code>**kwargs</code>是关键字参数，赋值的时候是以键值对的方式，参数可以是任意多对在定义函数的时候</li>
<li>不确定会有多少参数会传入时，就可以使用两个参数。</li>
</ul>
<h2 id="map与reduce函数"><a href="#map与reduce函数" class="headerlink" title="map与reduce函数"></a><code>map</code>与<code>reduce</code>函数</h2><ul>
<li><code>map()</code>是将传入的函数依次作用到序列的每个元素，每个元素都是独自被函数“作用”一次 。</li>
<li><code>reduce()</code>是将传入的函数作用在序列的第一个元素得到结果后，把这个结果继续与下一个元素作用（累</li>
</ul>
<p>积计算）。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">map</span>(<span class="keyword">lambda</span> x: x * x, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>])   <span class="comment"># 使用 lambda</span></span><br><span class="line"><span class="comment"># [1, 4, 9, 16]</span></span><br><span class="line">reduce(<span class="keyword">lambda</span> x, y: x * y, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>])  <span class="comment"># 相当于 ((1 * 2) * 3) * 4</span></span><br><span class="line"><span class="comment"># 24</span></span><br></pre></td></tr></table></figure>

<h2 id="hasattr-getattr-setattr-函数使用详解？"><a href="#hasattr-getattr-setattr-函数使用详解？" class="headerlink" title="hasattr(), getattr(), setattr()函数使用详解？"></a><code>hasattr()</code>, <code>getattr()</code>, <code>setattr()</code>函数使用详解？</h2><ol>
<li><code>hasattr(object, name)</code>函数：</li>
</ol>
<p>判断一个对象里面是否有 name 属性或者 name 方法，返回 bool 值，有 name 属性（方法）返回 True，否则返回 False。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">function_demo</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">	name = <span class="string">&#x27;demo&#x27;</span></span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self</span>):</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;hello function&quot;</span></span><br><span class="line">functiondemo = function_demo()</span><br><span class="line">res = <span class="built_in">hasattr</span>(functiondemo, <span class="string">&quot;name&quot;</span>) <span class="comment"># 判断对象是否有name属性，True</span></span><br><span class="line">res = <span class="built_in">hasattr</span>(functiondemo, <span class="string">&quot;run&quot;</span>)  <span class="comment"># 判断对象是否有run方法，True</span></span><br><span class="line">res = <span class="built_in">hasattr</span>(functiondemo, <span class="string">&quot;age&quot;</span>)  <span class="comment"># 判断对象是否有age属性，False</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li><code>getattr(object, name[,default])</code>函数：</li>
</ol>
<p>获取对象 object 的属性或者方法，如果存在则打印出来，如果不存在，打印默认值，默认值可选。<br>注意：如果返回的是对象的方法，则打印结果是：方法的内存地址，如果需要运行这个方法，可以在后面添加括号()</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">function_demo</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">	name = <span class="string">&#x27;demo&#x27;</span></span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self</span>):</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;hello function&quot;</span></span><br><span class="line">functiondemo = function_demo()</span><br><span class="line"><span class="built_in">getattr</span>(functiondemo, <span class="string">&quot;name&quot;</span>)<span class="comment"># 获取name属性，存在就打印出来 --- demo</span></span><br><span class="line"><span class="built_in">getattr</span>(functiondemo, <span class="string">&quot;run&quot;</span>) <span class="comment"># 获取run 方法，存在打印出方法的内存地址</span></span><br><span class="line"><span class="built_in">getattr</span>(functiondemo, <span class="string">&quot;age&quot;</span>) <span class="comment"># 获取不存在的属性，报错</span></span><br><span class="line"><span class="built_in">getattr</span>(functiondemo, <span class="string">&quot;age&quot;</span>, <span class="number">18</span>) <span class="comment"># 获取不存在的属性，返回一个默认值</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li><code>setattr(object, name, values)</code>函数：</li>
</ol>
<p>给对象的属性赋值，若属性不存在，先创建再赋值</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">function_demo</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">	name = <span class="string">&quot;demo&quot;</span></span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self</span>):</span><br><span class="line">			<span class="keyword">return</span> <span class="string">&quot;hello function&quot;</span></span><br><span class="line">functiondemo = function_demo()</span><br><span class="line">res = <span class="built_in">hasattr</span>(functiondemo, <span class="string">&quot;age&quot;</span>) <span class="comment"># 判断age属性是否存在，False</span></span><br><span class="line"><span class="built_in">print</span>(res)</span><br><span class="line"><span class="built_in">setattr</span>(functiondemo, <span class="string">&quot;age&quot;</span>, <span class="number">18</span>) <span class="comment"># 对age属性进行赋值，无返回值</span></span><br><span class="line">res = <span class="built_in">hasattr</span>(functiondemo, <span class="string">&quot;age&quot;</span>) <span class="comment"># 再次判断属性是否存在，True</span></span><br><span class="line"><span class="built_in">print</span>(res)</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>综合使用</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">function_demo</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">	name = <span class="string">&quot;demo&quot;</span></span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self</span>):</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;hello function&quot;</span></span><br><span class="line">functiondemo = function_demo()</span><br><span class="line">res = <span class="built_in">hasattr</span>(functiondemo, <span class="string">&quot;addr&quot;</span>) <span class="comment"># 先判断是否存在</span></span><br><span class="line"><span class="keyword">if</span> res:</span><br><span class="line">	addr = <span class="built_in">getattr</span>(functiondemo, <span class="string">&quot;addr&quot;</span>)</span><br><span class="line">	<span class="built_in">print</span>(addr)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">	addr = <span class="built_in">getattr</span>(functiondemo, <span class="string">&quot;addr&quot;</span>, <span class="built_in">setattr</span>(functiondemo, <span class="string">&quot;addr&quot;</span>, <span class="string">&quot;北京首</span></span><br><span class="line"><span class="string">都&quot;</span>))</span><br><span class="line">	<span class="built_in">print</span>(addr)</span><br></pre></td></tr></table></figure>

<h2 id="什么是断言-assert-？"><a href="#什么是断言-assert-？" class="headerlink" title="什么是断言(assert)？"></a>什么是断言(assert)？</h2><p><strong>assert 断言</strong>——声明其布尔值必须为真判定，发生异常则为假。</p>
<h2 id="Python-是如何进行类型转换的？"><a href="#Python-是如何进行类型转换的？" class="headerlink" title="Python 是如何进行类型转换的？"></a>Python 是如何进行类型转换的？</h2><p>内建函数(build-in)封装了各种转换函数，可以使用目标类型关键字强制类型转换<br>进制之间的转换可以用<code>int(str, base=&#39;n&#39;)</code>将特定进制的字符串转换为十进制，再用相应的进制转换函数将十进制转换为目标进制。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># hex to decimal</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">int</span>(<span class="string">&#x27;0xf&#x27;</span>, <span class="number">16</span>))  <span class="comment"># 15</span></span><br><span class="line"><span class="comment"># binary to decimal</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">int</span>(<span class="string">&#x27;10100111110&#x27;</span>, <span class="number">2</span>))  <span class="comment"># 1342</span></span><br><span class="line"><span class="comment"># octonary to decimal</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">int</span>(<span class="string">&#x27;17&#x27;</span>, <span class="number">8</span>))  <span class="comment"># 15</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># decimal to hex</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(<span class="number">1033</span>))  <span class="comment"># 0x409</span></span><br><span class="line"><span class="comment"># binary to hex</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(<span class="built_in">int</span>(<span class="string">&#x27;101010&#x27;</span>, <span class="number">2</span>))) <span class="comment"># 0x2a</span></span><br><span class="line"><span class="comment"># oct to hex</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(<span class="built_in">int</span>(<span class="string">&#x27;17&#x27;</span>, <span class="number">8</span>)))  <span class="comment"># 0xf</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># decimal to binary</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">bin</span>(<span class="number">10</span>))  <span class="comment"># 0b1010</span></span><br><span class="line"><span class="comment"># hex to bin</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">bin</span>(<span class="built_in">int</span>(<span class="string">&#x27;0xff&#x27;</span>, <span class="number">16</span>)))  <span class="comment"># 0b11111111</span></span><br><span class="line"><span class="comment"># oct to bin</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">bin</span>(<span class="built_in">int</span>(<span class="string">&#x27;17&#x27;</span>,<span class="number">8</span>)))  <span class="comment"># 0b1111</span></span><br></pre></td></tr></table></figure>

<h2 id="提高-Python-运行效率的方法？"><a href="#提高-Python-运行效率的方法？" class="headerlink" title="提高 Python 运行效率的方法？"></a>提高 Python 运行效率的方法？</h2><ol>
<li><p>使用生成器，因为可以节约大量内存</p>
</li>
<li><p>循环代码优化，避免过多重复代码的执行</p>
</li>
<li><p>核心模块用 Cython PyPy 等，提高效率</p>
</li>
<li><p>多进程, 多线程, 协程</p>
</li>
<li><p>多个 if elif 条件判断，可以把最有可能先发生的条件放到前面写，这样可以减少程序判断的次数，提高效率</p>
</li>
</ol>
<h2 id="Python-中any-和all-方法"><a href="#Python-中any-和all-方法" class="headerlink" title="Python 中any()和all()方法"></a>Python 中<code>any()</code>和<code>all()</code>方法</h2><ul>
<li><code>any()</code>：只要可迭代对象中有一个元素为真就为真</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">any</span>(<span class="params">iterable</span>):</span><br><span class="line">    <span class="keyword">for</span> element <span class="keyword">in</span> iterable:</span><br><span class="line">        <span class="keyword">if</span> element:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>all()</code>：可迭代对象中所有的判断项返回都是真，结果才为真</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">all</span>(<span class="params">iterable</span>):</span><br><span class="line">    <span class="keyword">for</span> element <span class="keyword">in</span> iterable:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> element:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>

<h2 id="Python-为假的变量"><a href="#Python-为假的变量" class="headerlink" title="Python 为假的变量"></a>Python 为假的变量</h2><p>0，空字符串，空列表，空字典，空元组，None，False</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="http://example.com">YUAN Tingyi</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="http://example.com/2022/05/30/8f191998df9746e1aeeae97ca644236b/">http://example.com/2022/05/30/8f191998df9746e1aeeae97ca644236b/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="/img/4.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/gh/overtrue/share.js@master/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-full"><a href="/2022/05/31/297d89bb91884aed8f829de39ec9c84b/"><img class="prev-cover" src="/img/7.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">Previous Post</div><div class="prev_info">TCP/IP简介</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/avatar.jpeg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">YUAN Tingyi</div><div class="author-info__description">XianrenYty</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">28</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/XianrenYty"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>Announcement</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Catalog</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95-Python-%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E7%82%B9"><span class="toc-number">1.</span> <span class="toc-text">算法面试 Python 相关知识点</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E8%A7%A3%E9%87%8A%E6%80%A7%E8%AF%AD%E8%A8%80%EF%BC%8C%E4%BB%80%E4%B9%88%E6%98%AF%E7%BC%96%E8%AF%91%E6%80%A7%E8%AF%AD%E8%A8%80%EF%BC%9F"><span class="toc-number">1.1.</span> <span class="toc-text">什么是解释性语言，什么是编译性语言？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Python-%E7%A8%8B%E5%BA%8F%E8%BF%90%E8%A1%8C%E8%BF%87%E7%A8%8B%EF%BC%9F"><span class="toc-number">1.2.</span> <span class="toc-text">Python 程序运行过程？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Python-%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F%EF%BC%9F"><span class="toc-number">1.3.</span> <span class="toc-text">Python 的作用域？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Python-%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9F"><span class="toc-number">1.4.</span> <span class="toc-text">Python 的数据结构？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B"><span class="toc-number">1.5.</span> <span class="toc-text">进程和线程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Lambda"><span class="toc-number">1.6.</span> <span class="toc-text">Lambda</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%85%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B7%B1%E6%8B%B7%E8%B4%9D"><span class="toc-number">1.7.</span> <span class="toc-text">浅拷贝和深拷贝</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Python-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%98%AF%E5%90%A6%E8%83%BD%E7%94%A8%E5%A4%9A%E4%B8%AA-CPU%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">1.8.</span> <span class="toc-text">Python 多线程是否能用多个 CPU，为什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Python-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6"><span class="toc-number">1.9.</span> <span class="toc-text">Python 垃圾回收机制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Python-%E7%94%9F%E6%88%90%E5%99%A8"><span class="toc-number">1.10.</span> <span class="toc-text">Python 生成器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Python-%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%92%8C%E7%94%9F%E6%88%90%E5%99%A8%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.11.</span> <span class="toc-text">Python 迭代器和生成器的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E9%97%AD%E5%8C%85"><span class="toc-number">1.12.</span> <span class="toc-text">什么是闭包</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Python-%E8%A3%85%E9%A5%B0%E5%99%A8"><span class="toc-number">1.13.</span> <span class="toc-text">Python 装饰器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A3%85%E9%A5%B0%E5%99%A8"><span class="toc-number">1.13.1.</span> <span class="toc-text">装饰器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%A6%E5%8F%82%E6%95%B0%E7%9A%84%E8%A3%85%E9%A5%B0%E5%99%A8"><span class="toc-number">1.13.2.</span> <span class="toc-text">带参数的装饰器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E8%A3%85%E9%A5%B0%E5%99%A8"><span class="toc-number">1.13.3.</span> <span class="toc-text">类装饰器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Python-%E4%B8%AD-yield-%E5%92%8C-return-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.14.</span> <span class="toc-text">Python 中 yield 和 return 的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Python-%E4%B8%AD-set-%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.15.</span> <span class="toc-text">Python 中 set 的底层实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Python-%E4%B8%AD%E5%AD%97%E5%85%B8%E4%B8%8E-set-%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">1.16.</span> <span class="toc-text">Python 中字典与 set 区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Python-%E4%B8%AD-init-%E5%92%8C-new-%E5%92%8C-call-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">1.17.</span> <span class="toc-text">Python 中__init__和__new__和__call__的区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Python-%E4%B8%AD%E7%9A%84%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="toc-number">1.18.</span> <span class="toc-text">Python 中的内存管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%99%A8%EF%BC%88what%EF%BC%89"><span class="toc-number">1.18.1.</span> <span class="toc-text">什么是内存管理器（what）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Python-%E5%86%85%E5%AD%98%E6%B1%A0"><span class="toc-number">1.18.2.</span> <span class="toc-text">Python 内存池</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6"><span class="toc-number">1.18.3.</span> <span class="toc-text">垃圾回收机制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0"><span class="toc-number">1.18.3.1.</span> <span class="toc-text">引用计数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%87%E8%AE%B0-%E6%B8%85%E9%99%A4%EF%BC%88Mark-and-Sweep%EF%BC%89"><span class="toc-number">1.18.3.2.</span> <span class="toc-text">标记-清除（Mark-and-Sweep）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E4%BB%A3%E5%9B%9E%E6%94%B6"><span class="toc-number">1.18.3.3.</span> <span class="toc-text">分代回收</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E6%96%B9%E6%B3%95%E5%92%8C%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.19.</span> <span class="toc-text">类方法和静态方法的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Python-%E7%9A%84%E9%94%99%E8%AF%AF%E5%92%8C%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86"><span class="toc-number">1.20.</span> <span class="toc-text">Python 的错误和异常处理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Python-%E4%B8%AD%E7%9A%84-is-%E5%92%8C-x3D-x3D-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.21.</span> <span class="toc-text">Python 中的 is 和&#x3D;&#x3D;的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#GBK-%E5%92%8C-UTF-8-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.22.</span> <span class="toc-text">GBK 和 UTF-8 的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Python-%E9%81%8D%E5%8E%86%E5%AD%97%E5%85%B8%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">1.23.</span> <span class="toc-text">Python 遍历字典的方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#init-py%E6%96%87%E4%BB%B6%E7%9A%84%E4%BD%9C%E7%94%A8%E4%BB%A5%E5%8F%8A%E6%84%8F%E4%B9%89"><span class="toc-number">1.24.</span> <span class="toc-text">__init__.py文件的作用以及意义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E5%8F%82%E6%95%B0%E7%9A%84%E4%BC%A0%E9%80%92%E6%96%B9%E5%BC%8F%E6%98%AF%E5%80%BC%E4%BC%A0%E9%80%92%E8%BF%98%E6%98%AF%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92%EF%BC%9F"><span class="toc-number">1.25.</span> <span class="toc-text">函数调用参数的传递方式是值传递还是引用传递？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Python-%E7%9A%84%E7%BC%BA%E7%9C%81%E5%8F%82%E6%95%B0"><span class="toc-number">1.26.</span> <span class="toc-text">Python 的缺省参数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#map%E4%B8%8Ereduce%E5%87%BD%E6%95%B0"><span class="toc-number">1.27.</span> <span class="toc-text">map与reduce函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#hasattr-getattr-setattr-%E5%87%BD%E6%95%B0%E4%BD%BF%E7%94%A8%E8%AF%A6%E8%A7%A3%EF%BC%9F"><span class="toc-number">1.28.</span> <span class="toc-text">hasattr(), getattr(), setattr()函数使用详解？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%96%AD%E8%A8%80-assert-%EF%BC%9F"><span class="toc-number">1.29.</span> <span class="toc-text">什么是断言(assert)？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Python-%E6%98%AF%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E7%9A%84%EF%BC%9F"><span class="toc-number">1.30.</span> <span class="toc-text">Python 是如何进行类型转换的？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8F%90%E9%AB%98-Python-%E8%BF%90%E8%A1%8C%E6%95%88%E7%8E%87%E7%9A%84%E6%96%B9%E6%B3%95%EF%BC%9F"><span class="toc-number">1.31.</span> <span class="toc-text">提高 Python 运行效率的方法？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Python-%E4%B8%ADany-%E5%92%8Call-%E6%96%B9%E6%B3%95"><span class="toc-number">1.32.</span> <span class="toc-text">Python 中any()和all()方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Python-%E4%B8%BA%E5%81%87%E7%9A%84%E5%8F%98%E9%87%8F"><span class="toc-number">1.33.</span> <span class="toc-text">Python 为假的变量</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Post</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2022/06/01/fd61228310d24c999c625f49b503f7ce/" title="train_test_split 参数详解"><img src="/img/8.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="train_test_split 参数详解"/></a><div class="content"><a class="title" href="/2022/06/01/fd61228310d24c999c625f49b503f7ce/" title="train_test_split 参数详解">train_test_split 参数详解</a><time datetime="2022-06-01T12:52:00.000Z" title="Created 2022-06-01 20:52:00">2022-06-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/06/01/224bdd4444be4fe0b7826959bc6b40a4/" title="StandardScaler(sklearn)参数详解"><img src="/img/8.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="StandardScaler(sklearn)参数详解"/></a><div class="content"><a class="title" href="/2022/06/01/224bdd4444be4fe0b7826959bc6b40a4/" title="StandardScaler(sklearn)参数详解">StandardScaler(sklearn)参数详解</a><time datetime="2022-06-01T12:51:39.966Z" title="Created 2022-06-01 20:51:39">2022-06-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/06/01/2fd9e712ce6b4a49a24775586e47e44b/" title="八大排序算法(Python实现)"><img src="/img/5.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="八大排序算法(Python实现)"/></a><div class="content"><a class="title" href="/2022/06/01/2fd9e712ce6b4a49a24775586e47e44b/" title="八大排序算法(Python实现)">八大排序算法(Python实现)</a><time datetime="2022-06-01T12:51:26.086Z" title="Created 2022-06-01 20:51:26">2022-06-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/06/01/9d8547900901416593ba964e6757c6c3/" title="ResNet"><img src="/img/9.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="ResNet"/></a><div class="content"><a class="title" href="/2022/06/01/9d8547900901416593ba964e6757c6c3/" title="ResNet">ResNet</a><time datetime="2022-06-01T12:50:56.055Z" title="Created 2022-06-01 20:50:56">2022-06-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/06/01/b6a6cbce3d7f45a8b2511edf86fb5a24/" title="Paddle高层API实现图像分类（CIFAR-100数据集_ResNet101）"><img src="/img/5.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Paddle高层API实现图像分类（CIFAR-100数据集_ResNet101）"/></a><div class="content"><a class="title" href="/2022/06/01/b6a6cbce3d7f45a8b2511edf86fb5a24/" title="Paddle高层API实现图像分类（CIFAR-100数据集_ResNet101）">Paddle高层API实现图像分类（CIFAR-100数据集_ResNet101）</a><time datetime="2022-06-01T12:48:23.363Z" title="Created 2022-06-01 20:48:23">2022-06-01</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By YUAN Tingyi</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Switch Between Light And Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle between single-column and double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="Setting"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back To Top"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>